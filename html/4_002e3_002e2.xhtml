<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Structure and Interpretation of Computer Programs, 2e: 4.3.2</title>

<meta name="description" content="Structure and Interpretation of Computer Programs, 2e: 4.3.2" />
<meta name="keywords" content="Structure and Interpretation of Computer Programs, 2e: 4.3.2" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="Generator" content="texi2any" />
<meta charset="utf-8" />
<link href="index.xhtml#Top" rel="start" title="Top" />
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index" />
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents" />
<link href="4_002e3.xhtml#g_t4_002e3" rel="prev" title="4.3" />
<link href="4_002e3_002e3.xhtml#g_t4_002e3_002e3" rel="next" title="4.3.3" />
<link href="4_002e3_002e1.xhtml#g_t4_002e3_002e1" rel="prev" title="4.3.1" />

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script src="js/jquery.min.js" type="text/javascript"></script>
<script src="js/footnotes.js" type="text/javascript"></script>
<script src="js/browsertest.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t4_002e3_002e2"></a>
<nav class="header">
<p>
Next: <a href="4_002e3_002e3.xhtml#g_t4_002e3_002e3" accesskey="n" rel="next">4.3.3</a>, Previous: <a href="4_002e3_002e1.xhtml#g_t4_002e3_002e1" accesskey="p" rel="prev">4.3.1</a>, Up: <a href="4_002e3.xhtml#g_t4_002e3" accesskey="u" rel="prev">4.3</a>   [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr />

<a id="Examples-of-Nondeterministic-Programs"></a>
<h4 class="subsection"><span class="secnum">4.3.2</span><span class="sectitle">Examples of Nondeterministic Programs</span></h4>

<p>Section <a href="4_002e3_002e3.xhtml#g_t4_002e3_002e3">4.3.3</a> describes the implementation of the <code>amb</code> evaluator.
First, however, we give some examples of how it can be used.  The advantage of
nondeterministic programming is that we can suppress the details of how search
is carried out, thereby expressing our programs at a higher level of
abstraction.
</p>
<a id="Logic-Puzzles"></a>
<h5 class="subsubheading">Logic Puzzles</h5>

<p>The following puzzle (taken from <a href="References.xhtml#Dinesman-1968">Dinesman 1968</a>) is typical of a large class of
simple logic puzzles:
</p>
<blockquote>
<p>Baker, Cooper, Fletcher, Miller, and Smith live on different floors of an
apartment house that contains only five floors.  Baker does not live on the top
floor.  Cooper does not live on the bottom floor.  Fletcher does not live on
either the top or the bottom floor.  Miller lives on a higher floor than does
Cooper.  Smith does not live on a floor adjacent to Fletcher’s.  Fletcher does
not live on a floor adjacent to Cooper’s.  Where does everyone live?
</p></blockquote>

<p>We can determine who lives on each floor in a straightforward way by
enumerating all the possibilities and imposing the given
restrictions:<a class="footnote_link" id="DOCF252" href="#FOOT252"><sup>252</sup></a>
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">multiple-dwelling</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">baker </span><span class="opn">(</span><span class="pln">amb </span><span class="lit">1</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="lit">3</span><span class="pln"> </span><span class="lit">4</span><span class="pln"> </span><span class="lit">5</span><span class="clo">))</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">cooper </span><span class="opn">(</span><span class="pln">amb </span><span class="lit">1</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="lit">3</span><span class="pln"> </span><span class="lit">4</span><span class="pln"> </span><span class="lit">5</span><span class="clo">))</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">fletcher </span><span class="opn">(</span><span class="pln">amb </span><span class="lit">1</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="lit">3</span><span class="pln"> </span><span class="lit">4</span><span class="pln"> </span><span class="lit">5</span><span class="clo">))</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">miller </span><span class="opn">(</span><span class="pln">amb </span><span class="lit">1</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="lit">3</span><span class="pln"> </span><span class="lit">4</span><span class="pln"> </span><span class="lit">5</span><span class="clo">))</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">smith </span><span class="opn">(</span><span class="pln">amb </span><span class="lit">1</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="lit">3</span><span class="pln"> </span><span class="lit">4</span><span class="pln"> </span><span class="lit">5</span><span class="clo">)))</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">require
     </span><span class="opn">(</span><span class="pln">distinct? </span><span class="opn">(</span><span class="pln">list baker cooper fletcher 
                      miller smith</span><span class="clo">)))</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">require </span><span class="opn">(</span><span class="pln">not </span><span class="opn">(</span><span class="pun">=</span><span class="pln"> baker </span><span class="lit">5</span><span class="clo">)))</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">require </span><span class="opn">(</span><span class="pln">not </span><span class="opn">(</span><span class="pun">=</span><span class="pln"> cooper </span><span class="lit">1</span><span class="clo">)))</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">require </span><span class="opn">(</span><span class="pln">not </span><span class="opn">(</span><span class="pun">=</span><span class="pln"> fletcher </span><span class="lit">5</span><span class="clo">)))</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">require </span><span class="opn">(</span><span class="pln">not </span><span class="opn">(</span><span class="pun">=</span><span class="pln"> fletcher </span><span class="lit">1</span><span class="clo">)))</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">require </span><span class="opn">(</span><span class="pun">&gt;</span><span class="pln"> miller cooper</span><span class="clo">))</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">require
     </span><span class="opn">(</span><span class="pln">not </span><span class="opn">(</span><span class="pun">=</span><span class="pln"> </span><span class="opn">(</span><span class="pln">abs </span><span class="opn">(</span><span class="pun">-</span><span class="pln"> smith fletcher</span><span class="clo">))</span><span class="pln"> </span><span class="lit">1</span><span class="clo">)))</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">require 
     </span><span class="opn">(</span><span class="pln">not </span><span class="opn">(</span><span class="pun">=</span><span class="pln"> </span><span class="opn">(</span><span class="pln">abs </span><span class="opn">(</span><span class="pun">-</span><span class="pln"> fletcher cooper</span><span class="clo">))</span><span class="pln"> </span><span class="lit">1</span><span class="clo">)))</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">list </span><span class="opn">(</span><span class="pln">list </span><span class="lit">'baker</span><span class="pln"> baker</span><span class="clo">)</span><span class="pln">
          </span><span class="opn">(</span><span class="pln">list </span><span class="lit">'cooper</span><span class="pln"> cooper</span><span class="clo">)</span><span class="pln">
          </span><span class="opn">(</span><span class="pln">list </span><span class="lit">'fletcher</span><span class="pln"> fletcher</span><span class="clo">)</span><span class="pln">
          </span><span class="opn">(</span><span class="pln">list </span><span class="lit">'miller</span><span class="pln"> miller</span><span class="clo">)</span><span class="pln">
          </span><span class="opn">(</span><span class="pln">list </span><span class="lit">'smith</span><span class="pln"> smith</span><span class="clo">))))</span></pre></div>

<p>Evaluating the expression <code>(multiple-dwelling)</code> produces the result
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">((</span><span class="pln">baker </span><span class="lit">3</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">cooper </span><span class="lit">2</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">fletcher </span><span class="lit">4</span><span class="clo">)</span><span class="pln">
 </span><span class="opn">(</span><span class="pln">miller </span><span class="lit">5</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">smith </span><span class="lit">1</span><span class="clo">))</span></pre></div>

<p>Although this simple procedure works, it is very slow.  <a href="#Exercise-4_002e39">Exercise 4.39</a> and
<a href="#Exercise-4_002e40">Exercise 4.40</a> discuss some possible improvements.
</p>
<blockquote>
<p><strong><a id="Exercise-4_002e38"></a>Exercise 4.38:</strong> Modify the multiple-dwelling
procedure to omit the requirement that Smith and Fletcher do not live on
adjacent floors.  How many solutions are there to this modified puzzle?
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e39"></a>Exercise 4.39:</strong> Does the order of the
restrictions in the multiple-dwelling procedure affect the answer? Does it
affect the time to find an answer?  If you think it matters, demonstrate a
faster program obtained from the given one by reordering the restrictions.  If
you think it does not matter, argue your case.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e40"></a>Exercise 4.40:</strong> In the multiple dwelling problem,
how many sets of assignments are there of people to floors, both before and
after the requirement that floor assignments be distinct?  It is very
inefficient to generate all possible assignments of people to floors and then
leave it to backtracking to eliminate them.  For example, most of the
restrictions depend on only one or two of the person-floor variables, and can
thus be imposed before floors have been selected for all the people.  Write and
demonstrate a much more efficient nondeterministic procedure that solves this
problem based upon generating only those possibilities that are not already
ruled out by previous restrictions.  (Hint: This will require a nest of
<code>let</code> expressions.)
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e41"></a>Exercise 4.41:</strong> Write an ordinary Scheme program
to solve the multiple dwelling puzzle.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e42"></a>Exercise 4.42:</strong> Solve the following “Liars”
puzzle (from <a href="References.xhtml#Phillips-1934">Phillips 1934</a>):
</p>
<p>Five schoolgirls sat for an examination.  Their parents—so they
thought—showed an undue degree of interest in the result.  They therefore
agreed that, in writing home about the examination, each girl should make one
true statement and one untrue one.  The following are the relevant passages
from their letters:
</p>
<ul>
<li> Betty: “Kitty was second in the examination.  I was only third.”

</li><li> Ethel: “You’ll be glad to hear that I was on top.  Joan was second.”

</li><li> Joan: “I was third, and poor old Ethel was bottom.”

</li><li> Kitty: “I came out second.  Mary was only fourth.”

</li><li> Mary: “I was fourth.  Top place was taken by Betty.”

</li></ul>

<p>What in fact was the order in which the five girls were placed?
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e43"></a>Exercise 4.43:</strong> Use the <code>amb</code> evaluator to
solve the following puzzle:<a class="footnote_link" id="DOCF253" href="#FOOT253"><sup>253</sup></a>
</p>
<blockquote>
<p>Mary Ann Moore’s father has a yacht and so has each of his four friends:
Colonel Downing, Mr. Hall, Sir Barnacle Hood, and Dr.  Parker.  Each of the
five also has one daughter and each has named his yacht after a daughter of one
of the others.  Sir Barnacle’s yacht is the Gabrielle, Mr. Moore owns the
Lorna; Mr. Hall the Rosalind.  The Melissa, owned by Colonel Downing, is named
after Sir Barnacle’s daughter.  Gabrielle’s father owns the yacht that is named
after Dr.  Parker’s daughter.  Who is Lorna’s father?
</p></blockquote>

<p>Try to write the program so that it runs efficiently (see <a href="#Exercise-4_002e40">Exercise 4.40</a>).
Also determine how many solutions there are if we are not told that Mary Ann’s
last name is Moore.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e44"></a>Exercise 4.44:</strong> <a href="2_002e2_002e3.xhtml#Exercise-2_002e42">Exercise 2.42</a> described the
“eight-queens puzzle” of placing queens on a chessboard so that no two attack
each other.  Write a nondeterministic program to solve this puzzle.
</p></blockquote>

<a id="Parsing-natural-language"></a>
<h5 class="subsubheading">Parsing natural language</h5>

<p>Programs designed to accept natural language as input usually start by
attempting to <a id="index-parse"></a>
<em>parse</em> the input, that is, to match the input against
some grammatical structure.  For example, we might try to recognize simple
sentences consisting of an article followed by a noun followed by a verb, such
as “The cat eats.”  To accomplish such an analysis, we must be able to
identify the parts of speech of individual words.  We could start with some
lists that classify various words:<a class="footnote_link" id="DOCF254" href="#FOOT254"><sup>254</sup></a>
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> nouns 
  </span><span class="lit">'</span><span class="opn">(</span><span class="pln">noun student professor cat class</span><span class="clo">))</span><span class="pln">

</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> verbs 
  </span><span class="lit">'</span><span class="opn">(</span><span class="pln">verb studies lectures eats sleeps</span><span class="clo">))</span><span class="pln">

</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> articles </span><span class="lit">'</span><span class="opn">(</span><span class="pln">article the a</span><span class="clo">))</span></pre></div>

<p>We also need a <a id="index-grammar"></a>
<em>grammar</em>, that is, a set of rules describing how
grammatical elements are composed from simpler elements.  A very simple grammar
might stipulate that a sentence always consists of two pieces—a noun phrase
followed by a verb—and that a noun phrase consists of an article followed by
a noun.  With this grammar, the sentence “The cat eats” is parsed as follows:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">sentence
 </span><span class="opn">(</span><span class="pln">noun-phrase </span><span class="opn">(</span><span class="pln">article the</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">noun cat</span><span class="clo">))</span><span class="pln">
 </span><span class="opn">(</span><span class="pln">verb eats</span><span class="clo">))</span></pre></div>

<p>We can generate such a parse with a simple program that has separate procedures
for each of the grammatical rules.  To parse a sentence, we identify its two
constituent pieces and return a list of these two elements, tagged with the
symbol <code>sentence</code>:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">parse-sentence</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">list </span><span class="lit">'sentence</span><span class="pln">
         </span><span class="opn">(</span><span class="pln">parse-noun-phrase</span><span class="clo">)</span><span class="pln">
         </span><span class="opn">(</span><span class="pln">parse-word verbs</span><span class="clo">)))</span></pre></div>

<p>A noun phrase, similarly, is parsed by finding an article followed by a
noun:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">parse-noun-phrase</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">list </span><span class="lit">'noun-phrase</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">parse-word articles</span><span class="clo">)</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">parse-word nouns</span><span class="clo">)))</span></pre></div>

<p>At the lowest level, parsing boils down to repeatedly checking that the next
unparsed word is a member of the list of words for the required part of speech.
To implement this, we maintain a global variable <code>*unparsed*</code>, which is
the input that has not yet been parsed.  Each time we check a word, we require
that <code>*unparsed*</code> must be non-empty and that it should begin with a word
from the designated list.  If so, we remove that word from <code>*unparsed*</code>
and return the word together with its part of speech (which is found at the
head of the list):<a class="footnote_link" id="DOCF255" href="#FOOT255"><sup>255</sup></a>
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">parse-word word-list</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">require </span><span class="opn">(</span><span class="pln">not </span><span class="opn">(</span><span class="pln">null? </span><span class="pun">*</span><span class="pln">unparsed</span><span class="pun">*</span><span class="clo">)))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">require </span><span class="opn">(</span><span class="pln">memq </span><span class="opn">(</span><span class="kwd">car</span><span class="pln"> </span><span class="pun">*</span><span class="pln">unparsed</span><span class="pun">*</span><span class="clo">)</span><span class="pln"> 
                 </span><span class="opn">(</span><span class="kwd">cdr</span><span class="pln"> word-list</span><span class="clo">)))</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">found-word </span><span class="opn">(</span><span class="kwd">car</span><span class="pln"> </span><span class="pun">*</span><span class="pln">unparsed</span><span class="pun">*</span><span class="clo">)))</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">set</span><span class="pun">!</span><span class="pln"> </span><span class="pun">*</span><span class="pln">unparsed</span><span class="pun">*</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">cdr</span><span class="pln"> </span><span class="pun">*</span><span class="pln">unparsed</span><span class="pun">*</span><span class="clo">))</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">list </span><span class="opn">(</span><span class="kwd">car</span><span class="pln"> word-list</span><span class="clo">)</span><span class="pln"> found-word</span><span class="clo">)))</span></pre></div>

<p>To start the parsing, all we need to do is set <code>*unparsed*</code> to be the
entire input, try to parse a sentence, and check that nothing is left over:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="pun">*</span><span class="pln">unparsed</span><span class="pun">*</span><span class="pln"> </span><span class="lit">'</span><span class="opn">(</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">parse input</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">set</span><span class="pun">!</span><span class="pln"> </span><span class="pun">*</span><span class="pln">unparsed</span><span class="pun">*</span><span class="pln"> input</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">sent </span><span class="opn">(</span><span class="pln">parse-sentence</span><span class="clo">)))</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">require </span><span class="opn">(</span><span class="pln">null? </span><span class="pun">*</span><span class="pln">unparsed</span><span class="pun">*</span><span class="clo">))</span><span class="pln">
    sent</span><span class="clo">))</span></pre></div>

<p>We can now try the parser and verify that it works for our simple test
sentence:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><i><span class="com">;;; Amb-Eval input:</span></i><span class="pln">
</span><span class="opn">(</span><span class="pln">parse </span><span class="lit">'</span><span class="opn">(</span><span class="pln">the cat eats</span><span class="clo">))</span><span class="pln">

</span><i><span class="com">;;; Starting a new problem</span></i><span class="pln">
</span><i><span class="com">;;; Amb-Eval value:</span></i><span class="pln">
</span><i><span class="opn">(</span><span class="pln">sentence 
 </span><span class="opn">(</span><span class="pln">noun-phrase </span><span class="opn">(</span><span class="pln">article the</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">noun cat</span><span class="clo">))</span><span class="pln">
 </span><span class="opn">(</span><span class="pln">verb eats</span><span class="clo">))</span></i>
</pre></div>

<p>The <code>amb</code> evaluator is useful here because it is convenient to express the
parsing constraints with the aid of <code>require</code>.  Automatic search and
backtracking really pay off, however, when we consider more complex grammars
where there are choices for how the units can be decomposed.
</p>
<p>Let’s add to our grammar a list of prepositions:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> prepositions 
  </span><span class="lit">'</span><span class="opn">(</span><span class="pln">prep for to in by with</span><span class="clo">))</span></pre></div>

<p>and define a prepositional phrase (e.g., “for the cat”) to be a preposition
followed by a noun phrase:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">parse-prepositional-phrase</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">list </span><span class="lit">'prep-phrase</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">parse-word prepositions</span><span class="clo">)</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">parse-noun-phrase</span><span class="clo">)))</span></pre></div>

<p>Now we can define a sentence to be a noun phrase followed by a verb phrase,
where a verb phrase can be either a verb or a verb phrase extended by a
prepositional phrase:<a class="footnote_link" id="DOCF256" href="#FOOT256"><sup>256</sup></a>
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">parse-sentence</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">list </span><span class="lit">'sentence</span><span class="pln">
         </span><span class="opn">(</span><span class="pln">parse-noun-phrase</span><span class="clo">)</span><span class="pln">
         </span><span class="opn">(</span><span class="pln">parse-verb-phrase</span><span class="clo">)))</span><span class="pln">

</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">parse-verb-phrase</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">maybe-extend verb-phrase</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">amb 
     verb-phrase
     </span><span class="opn">(</span><span class="pln">maybe-extend 
      </span><span class="opn">(</span><span class="pln">list </span><span class="lit">'verb-phrase</span><span class="pln">
            verb-phrase
            </span><span class="opn">(</span><span class="pln">parse-prepositional-phrase</span><span class="clo">)))))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">maybe-extend </span><span class="opn">(</span><span class="pln">parse-word verbs</span><span class="clo">)))</span></pre></div>

<p>While we’re at it, we can also elaborate the definition of noun phrases to
permit such things as “a cat in the class.”  What we used to call a noun
phrase, we’ll now call a simple noun phrase, and a noun phrase will now be
either a simple noun phrase or a noun phrase extended by a prepositional
phrase:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">parse-simple-noun-phrase</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">list </span><span class="lit">'simple-noun-phrase</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">parse-word articles</span><span class="clo">)</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">parse-word nouns</span><span class="clo">)))</span><span class="pln">

</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">parse-noun-phrase</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">maybe-extend noun-phrase</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">amb 
     noun-phrase
     </span><span class="opn">(</span><span class="pln">maybe-extend 
      </span><span class="opn">(</span><span class="pln">list </span><span class="lit">'noun-phrase</span><span class="pln">
            noun-phrase
            </span><span class="opn">(</span><span class="pln">parse-prepositional-phrase</span><span class="clo">)))))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">maybe-extend </span><span class="opn">(</span><span class="pln">parse-simple-noun-phrase</span><span class="clo">)))</span></pre></div>

<p>Our new grammar lets us parse more complex sentences.  For example
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">parse </span><span class="lit">'</span><span class="opn">(</span><span class="pln">the student with the cat 
         sleeps in the class</span><span class="clo">))</span></pre></div>

<p>produces
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">sentence
 </span><span class="opn">(</span><span class="pln">noun-phrase
  </span><span class="opn">(</span><span class="pln">simple-noun-phrase </span><span class="opn">(</span><span class="pln">article the</span><span class="clo">)</span><span class="pln"> 
                      </span><span class="opn">(</span><span class="pln">noun student</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">prep-phrase </span><span class="opn">(</span><span class="pln">prep with</span><span class="clo">)</span><span class="pln">
               </span><span class="opn">(</span><span class="pln">simple-noun-phrase
                </span><span class="opn">(</span><span class="pln">article the</span><span class="clo">)</span><span class="pln">
                </span><span class="opn">(</span><span class="pln">noun cat</span><span class="clo">))))</span><span class="pln">
 </span><span class="opn">(</span><span class="pln">verb-phrase
  </span><span class="opn">(</span><span class="pln">verb sleeps</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">prep-phrase </span><span class="opn">(</span><span class="pln">prep in</span><span class="clo">)</span><span class="pln">
               </span><span class="opn">(</span><span class="pln">simple-noun-phrase
                </span><span class="opn">(</span><span class="pln">article the</span><span class="clo">)</span><span class="pln">
                </span><span class="opn">(</span><span class="pln">noun class</span><span class="clo">)))))</span></pre></div>

<p>Observe that a given input may have more than one legal parse.  In the sentence
“The professor lectures to the student with the cat,” it may be that the
professor is lecturing with the cat, or that the student has the cat.  Our
nondeterministic program finds both possibilities:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">parse </span><span class="lit">'</span><span class="opn">(</span><span class="pln">the professor lectures to 
         the student with the cat</span><span class="clo">))</span></pre></div>

<p>produces
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">sentence
 </span><span class="opn">(</span><span class="pln">simple-noun-phrase </span><span class="opn">(</span><span class="pln">article the</span><span class="clo">)</span><span class="pln"> 
                     </span><span class="opn">(</span><span class="pln">noun professor</span><span class="clo">))</span><span class="pln">
 </span><span class="opn">(</span><span class="pln">verb-phrase
  </span><span class="opn">(</span><span class="pln">verb-phrase
   </span><span class="opn">(</span><span class="pln">verb lectures</span><span class="clo">)</span><span class="pln">
   </span><span class="opn">(</span><span class="pln">prep-phrase </span><span class="opn">(</span><span class="pln">prep to</span><span class="clo">)</span><span class="pln">
                </span><span class="opn">(</span><span class="pln">simple-noun-phrase
                 </span><span class="opn">(</span><span class="pln">article the</span><span class="clo">)</span><span class="pln"> 
                 </span><span class="opn">(</span><span class="pln">noun student</span><span class="clo">))))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">prep-phrase </span><span class="opn">(</span><span class="pln">prep with</span><span class="clo">)</span><span class="pln">
               </span><span class="opn">(</span><span class="pln">simple-noun-phrase
                </span><span class="opn">(</span><span class="pln">article the</span><span class="clo">)</span><span class="pln"> 
                </span><span class="opn">(</span><span class="pln">noun cat</span><span class="clo">)))))</span></pre></div>

<p>Asking the evaluator to try again yields
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">sentence
 </span><span class="opn">(</span><span class="pln">simple-noun-phrase </span><span class="opn">(</span><span class="pln">article the</span><span class="clo">)</span><span class="pln"> 
                     </span><span class="opn">(</span><span class="pln">noun professor</span><span class="clo">))</span><span class="pln">
 </span><span class="opn">(</span><span class="pln">verb-phrase </span><span class="opn">(</span><span class="pln">verb lectures</span><span class="clo">)</span><span class="pln">
              </span><span class="opn">(</span><span class="pln">prep-phrase 
               </span><span class="opn">(</span><span class="pln">prep to</span><span class="clo">)</span><span class="pln">
               </span><span class="opn">(</span><span class="pln">noun-phrase
                </span><span class="opn">(</span><span class="pln">simple-noun-phrase
                 </span><span class="opn">(</span><span class="pln">article the</span><span class="clo">)</span><span class="pln"> 
                 </span><span class="opn">(</span><span class="pln">noun student</span><span class="clo">))</span><span class="pln">
                </span><span class="opn">(</span><span class="pln">prep-phrase 
                 </span><span class="opn">(</span><span class="pln">prep with</span><span class="clo">)</span><span class="pln">
                 </span><span class="opn">(</span><span class="pln">simple-noun-phrase
                  </span><span class="opn">(</span><span class="pln">article the</span><span class="clo">)</span><span class="pln"> 
                  </span><span class="opn">(</span><span class="pln">noun cat</span><span class="clo">)))))))</span></pre></div>

<blockquote>
<p><strong><a id="Exercise-4_002e45"></a>Exercise 4.45:</strong> With the grammar given above, the
following sentence can be parsed in five different ways: “The professor
lectures to the student in the class with the cat.”  Give the five parses and
explain the differences in shades of meaning among them.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e46"></a>Exercise 4.46:</strong> The evaluators in 
<a href="4_002e1.xhtml#g_t4_002e1">4.1</a> and <a href="4_002e2.xhtml#g_t4_002e2">4.2</a> do not determine what order operands are evaluated in.
We will see that the <code>amb</code> evaluator evaluates them from left to right.
Explain why our parsing program wouldn’t work if the operands were evaluated in
some other order.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e47"></a>Exercise 4.47:</strong> Louis Reasoner suggests that,
since a verb phrase is either a verb or a verb phrase followed by a
prepositional phrase, it would be much more straightforward to define the
procedure <code>parse-verb-phrase</code> as follows (and similarly for noun phrases):
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">parse-verb-phrase</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">amb </span><span class="opn">(</span><span class="pln">parse-word verbs</span><span class="clo">)</span><span class="pln">
       </span><span class="opn">(</span><span class="pln">list 
        </span><span class="lit">'verb-phrase</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">parse-verb-phrase</span><span class="clo">)</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">parse-prepositional-phrase</span><span class="clo">))))</span></pre></div>

<p>Does this work?  Does the program’s behavior change if we interchange the order
of expressions in the <code>amb</code>?
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e48"></a>Exercise 4.48:</strong> Extend the grammar given above to
handle more complex sentences.  For example, you could extend noun phrases and
verb phrases to include adjectives and adverbs, or you could handle compound
sentences.<a class="footnote_link" id="DOCF257" href="#FOOT257"><sup>257</sup></a>
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e49"></a>Exercise 4.49:</strong> Alyssa P. Hacker is more
interested in generating interesting sentences than in parsing them.  She
reasons that by simply changing the procedure <code>parse-word</code> so that it
ignores the “input sentence” and instead always succeeds and generates an
appropriate word, we can use the programs we had built for parsing to do
generation instead.  Implement Alyssa’s idea, and show the first half-dozen or
so sentences generated.<a class="footnote_link" id="DOCF258" href="#FOOT258"><sup>258</sup></a>
</p></blockquote>

<div class="footnote">
<hr />

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT252"><p><a class="footnote_backlink" href="#DOCF252"><sup>252</sup></a>
Our program uses the following procedure to determine if
the elements of a list are distinct:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">distinct? items</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">cond</span><span class="pln"> </span><span class="opn">((</span><span class="pln">null? items</span><span class="clo">)</span><span class="pln"> true</span><span class="clo">)</span><span class="pln">
        </span><span class="opn">((</span><span class="pln">null? </span><span class="opn">(</span><span class="kwd">cdr</span><span class="pln"> items</span><span class="clo">))</span><span class="pln"> true</span><span class="clo">)</span><span class="pln">
        </span><span class="opn">((</span><span class="pln">member </span><span class="opn">(</span><span class="kwd">car</span><span class="pln"> items</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">cdr</span><span class="pln"> items</span><span class="clo">))</span><span class="pln"> false</span><span class="clo">)</span><span class="pln">
        </span><span class="opn">(</span><span class="kwd">else</span><span class="pln"> </span><span class="opn">(</span><span class="pln">distinct? </span><span class="opn">(</span><span class="kwd">cdr</span><span class="pln"> items</span><span class="clo">)))))</span></pre></div>

<p><code>Member</code> is like <code>memq</code> except that it uses <code>equal?</code> instead
of <code>eq?</code> to test for equality.</p>
</div>
<div id="FOOT253"><p><a class="footnote_backlink" href="#DOCF253"><sup>253</sup></a>
This is taken from a booklet called
“Problematical Recreations,” published in the 1960s by Litton Industries,
where it is attributed to the <cite>Kansas State Engineer</cite>.</p>
</div>
<div id="FOOT254"><p><a class="footnote_backlink" href="#DOCF254"><sup>254</sup></a>
Here we use the convention that the
first element of each list designates the part of speech for the rest of the
words in the list.</p>
</div>
<div id="FOOT255"><p><a class="footnote_backlink" href="#DOCF255"><sup>255</sup></a>
Notice that <code>parse-word</code> uses <code>set!</code> to
modify the unparsed input list.  For this to work, our <code>amb</code> evaluator
must undo the effects of <code>set!</code> operations when it backtracks.</p>
</div>
<div id="FOOT256"><p><a class="footnote_backlink" href="#DOCF256"><sup>256</sup></a>
Observe that this definition is recursive—a
verb may be followed by any number of prepositional phrases.</p>
</div>
<div id="FOOT257"><p><a class="footnote_backlink" href="#DOCF257"><sup>257</sup></a>
This kind of grammar can become arbitrarily complex, but it
is only a toy as far as real language understanding is concerned.  Real
natural-language understanding by computer requires an elaborate mixture of
syntactic analysis and interpretation of meaning.  On the other hand, even toy
parsers can be useful in supporting flexible command languages for programs
such as information-retrieval systems.  <a href="References.xhtml#Winston-1992">Winston 1992</a> discusses computational
approaches to real language understanding and also the applications of simple
grammars to command languages.</p>
</div>
<div id="FOOT258"><p><a class="footnote_backlink" href="#DOCF258"><sup>258</sup></a>
Although Alyssa’s idea works just fine (and is
surprisingly simple), the sentences that it generates are a bit boring—they
don’t sample the possible sentences of this language in a very interesting way.
In fact, the grammar is highly recursive in many places, and Alyssa’s technique
“falls into” one of these recursions and gets stuck.  See <a href="4_002e3_002e3.xhtml#Exercise-4_002e50">Exercise 4.50</a>
for a way to deal with this.</p>
</div>
</div>
<hr />
<nav class="header">
<p>
Next: <a href="4_002e3_002e3.xhtml#g_t4_002e3_002e3" accesskey="n" rel="next">4.3.3</a>, Previous: <a href="4_002e3_002e1.xhtml#g_t4_002e3_002e1" accesskey="p" rel="prev">4.3.1</a>, Up: <a href="4_002e3.xhtml#g_t4_002e3" accesskey="u" rel="prev">4.3</a>   [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>